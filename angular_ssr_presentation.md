# Angular Server Side Rendering
## with Angular 17

David Matos

---

## Why Server Side Rendering?

Traditional web crawlers struggled to interpret the dynamic content generated by Angular applications.

=> Results in incomplete indexing and poor search engine rankings.

SSR pre-renders the web page on the server and provides search engines static HTML content that is easily crawlable and indexable.

---

## Angular Universal <-> Angular SSR

Until Angular 16 the package was called angular-universal.

Since Angular 17 it's called angular-ssr - included into the Angular CLI.

---

## SSR Activation in an Angular Project

### Setup new Angular Project with SSR

```cmd
npx -p @angular/cli@17 ng new --directory . â€“ssr
```

##### Even without this param ```-ssr```, the user is asked during creation if SSR should be activated/generated.

### Add SSR to an existing angular project

```cmd
npx -p @angular/cli@17 ng add @angular/ssr
```

---

## Server Side Rendering Configuration

| Filename                   | folder      | description                                                                                                     |
|----------------------------|-------------|-----------------------------------------------------------------------------------------------------------------|
| ```server.ts```            | root folder | Express server that renders the app on the server and generates markup. |
| ```main.server.ts```       | /src        | Bootstraps application on the server with server config ```app.config.server.ts```. |
| ```app.config.server.ts``` | /src/app    | Server config, merged with appConfig. |

---

## server.ts

Express Server - listens to routes that should be rendered on the server:

```javascript
server.get('*', (req, res, next) => {
    const { protocol, originalUrl, baseUrl, headers } = req;

    commonEngine
      .render({
        bootstrap,
        documentFilePath: indexHtml,
        url: \`\${protocol}://\${headers.host}\${originalUrl}\`,
        publicPath: browserDistFolder,
        providers: [{ provide: APP_BASE_HREF, useValue: baseUrl }],
      })
      .then((html) => res.send(html))
      .catch((err) => next(err));
  });

  return server;
}
```

---

## app.config.server.ts

```ApplicationConfig``` with **Server Rendering Provider**,
merges the app config with the server config:

```javascript
import { appConfig } from './app.config';

const serverConfig: ApplicationConfig = {
  providers: [
    provideServerRendering()
  ]
};

export const config = mergeApplicationConfig(appConfig, serverConfig);
```

---

## Client Side Rendering Configuration

| Filename                 | folder   | description                                                    |
|--------------------------|----------|----------------------------------------------------------------|
| ```main.ts```       | /src     | Bootstraps the application on the client side with ```app.config.ts```. |
| ```app.config.ts``` | /src/app | App config for client-side rendering. |

---

## app.config.ts

```ApplicationConfig``` with **Client Hydration Provider**:

```javascript
import { provideClientHydration } from '@angular/platform-browser';

export const appConfig: ApplicationConfig = {
  providers: [provideRouter(routes), provideClientHydration()]
};
```

---

## Client Hydration

Hydration includes:

* Reusing server-rendered DOM structures.
* Persisting the application state.
* Transferring application data already retrieved by the server.

=> Improves performance by avoiding extra work to recreate DOM nodes.

---

## Caching

When SSR is enabled, HttpClient responses are cached while running on the server.

Caching is performed by default for all HEAD and GET requests.

Can be activated on POST requests and can be filtered (e.g., to deactivate caching for specific routes).

---

## Server Compatible Components

Some browser APIs and capabilities might not be available on the server, e.g.:

* Global objects like window, document, location, etc.
* Cookies and localStorage.

Angular-SSR provides:

---

* Property ```PLATFORM_ID```.
* Methods ```afterRender()``` and ```afterNextRender()``` to handle additional client-side rendering.

---

## ```PLATFORM_ID```

Provides a flag to identify if code is executed on the server or client:

```javascript
platformId = inject(PLATFORM_ID); // 'browser' or 'server'
```

---

## ```afterRender()``` and ```afterNextRender()```

Called after the page is rendered in the browser:

```javascript
export class WeatherComponent {
  weatherforcast: any;

  constructor(
      private weatherHandler: WeatherForCastService
  ) {
    // Weather forecast shall NOT be rendered on the server but on the client
    afterNextRender(() => {
      this.weatherHandler.getWeatherforcast().subscribe((data) => {
        this.weatherforcast = data;
      });
    });
  }
}
```

---

## Prerendering

With SSR activated, a prerender block is added to `angular.json`.

```json
"prerender": {
  "discoverRoutes": false,
  "routesFile": "prerenderedRoutes.txt"
},
```

```text
/products/1
/products/555
```

---

## Lifecycle

Steps performed when opening a route:

* Check if this route exists in the dist-browser folder (returns static HTML if yes).
* Server-side rendering occurs, and the page is delivered and displayed.
* Client-side rendering follows, with hydration adapting the DOM tree.

---

## Links

* [Angular 17 SSR - Server Side Rendering](https://angular.io/guide/ssr#server-side-rendering)
* [Angular Prerendering Documentation](https://angular.io/guide/prerendering)
